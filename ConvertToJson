import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.List;

public class FixedWidthTextToJsonConverter {

    public static void convertToJson(String textFilePath, String excelFilePath, String outputJsonPath) throws IOException {
        // Read all the rows from the fixed-width text file
        List<String> lines = Files.readAllLines(Paths.get(textFilePath));

        // Read the Excel file
        FileInputStream excelFile = new FileInputStream(new File(excelFilePath));
        Workbook workbook = new XSSFWorkbook(excelFile);
        Sheet sheet = workbook.getSheetAt(0); // Assuming the mapping is in the first sheet

        // Create an empty root JSON array (requestList)
        ObjectMapper mapper = new ObjectMapper();
        ArrayNode requestList = mapper.createArrayNode();

        // Iterate through each line in the text file
        for (String line : lines) {
            ObjectNode rootNode = mapper.createObjectNode(); // Create a new object for each row

            // Iterate through each row in the Excel sheet to build the JSON structure for each text line
            Iterator<Row> rowIterator = sheet.iterator();
            while (rowIterator.hasNext()) {
                Row row = rowIterator.next();
                String fieldName = row.getCell(0).getStringCellValue(); // Field name, e.g., "person.name"
                int startPos = (int) row.getCell(1).getNumericCellValue() - 1; // Start position (adjusting to 0-based index)
                int length = (int) row.getCell(2).getNumericCellValue(); // Length of the field
                int occurrence = (int) row.getCell(3).getNumericCellValue(); // Occurrence

                // Extract the text based on start position and length
                String extractedValue = extractValue(line, startPos, length);

                if (fieldName.contains("[]")) {
                    // Handle arrays (e.g., "projects[].name" or "skills[]")
                    String arrayFieldName = fieldName.substring(0, fieldName.indexOf("[]"));
                    String childField = fieldName.substring(fieldName.indexOf("[]") + 3);

                    // Get or create the array node
                    ArrayNode arrayNode = (ArrayNode) rootNode.get(arrayFieldName);
                    if (arrayNode == null) {
                        arrayNode = mapper.createArrayNode();
                        rootNode.set(arrayFieldName, arrayNode);
                    }

                    // Insert value into the appropriate array element
                    for (int i = 0; i < occurrence; i++) {
                        // Get or create the element at index 'i' in the array
                        ObjectNode itemNode;
                        if (arrayNode.size() > i) {
                            itemNode = (ObjectNode) arrayNode.get(i);
                        } else {
                            itemNode = mapper.createObjectNode();
                            arrayNode.add(itemNode);
                        }

                        if (childField.isEmpty()) {
                            // If there is no child field (e.g., "skills[]"), treat it as a simple value array
                            arrayNode.set(i, mapper.convertValue(extractedValue.trim(), JsonNode.class));
                        } else {
                            // Otherwise, set the value in the child field (e.g., "projects[].name")
                            itemNode.put(childField, extractedValue.trim());
                        }

                        // Update the start position for the next occurrence in the array
                        startPos += length;
                        extractedValue = extractValue(line, startPos, length); // Extract the next occurrence
                    }
                } else {
                    // Handle regular fields (non-array)
                    setNestedValue(rootNode, fieldName, extractedValue.trim());
                }
            }

            // Add the rootNode (current row object) to the requestList array
            requestList.add(rootNode);
        }

        workbook.close();

        // Create the final JSON structure with requestList
        ObjectNode finalJson = mapper.createObjectNode();
        finalJson.set("requestList", requestList);

        // Write the output JSON to a file
        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(outputJsonPath), finalJson);
        System.out.println("JSON file generated successfully at: " + outputJsonPath);
    }

    // Helper function to extract a substring based on start position and length
    private static String extractValue(String text, int startPos, int length) {
        if (startPos >= text.length()) return ""; // Out of bounds
        int endPos = Math.min(startPos + length, text.length());
        return text.substring(startPos, endPos);
    }

    // Helper function to set values in nested JSON nodes using dot notation
    private static void setNestedValue(ObjectNode node, String fieldName, String value) {
        String[] fields = fieldName.split("\\.");
        ObjectNode currentNode = node;

        for (int i = 0; i < fields.length - 1; i++) {
            String field = fields[i];
            JsonNode childNode = currentNode.get(field);

            // Create the node if it does not exist
            if (childNode == null || !childNode.isObject()) {
                childNode = currentNode.putObject(field);
            }

            // Traverse to the child node
            currentNode = (ObjectNode) childNode;
        }

        // Set the value at the final field
        currentNode.put(fields[fields.length - 1], value);
    }

    public static void main(String[] args) {
        try {
            String textFilePath = "output.txt";    // Path to your fixed-width text file
            String excelFilePath = "mapping.xlsx"; // Path to your Excel mapping file
            String outputJsonPath = "output.json"; // Path to your output JSON file

            convertToJson(textFilePath, excelFilePath, outputJsonPath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
