import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.*;
import java.nio.file.*;
import java.util.*;

public class GenericFileToJsonConverter {

    public static void main(String[] args) throws Exception {
        String templatePath = "template.xlsx";
        String dataFilePath = "data.txt";

        List<TemplateField> templateConfig = readTemplate(templatePath);
        List<String> dataLines = Files.readAllLines(Paths.get(dataFilePath));

        List<Map<String, String>> parsedData = parseData(dataLines, templateConfig);
        JSONObject jsonObject = buildJson(parsedData, templateConfig);

        System.out.println(jsonObject.toString(4));
    }

    // Using a record in Java 17 to model the template field
    record TemplateField(String fieldName, int startPosition, int length, int maxOccurrence, String jsonPath, String dataType) {}

    // Read template configuration from Excel file
    public static List<TemplateField> readTemplate(String templateFilePath) throws Exception {
        List<TemplateField> templateConfig = new ArrayList<>();
        try (FileInputStream fis = new FileInputStream(new File(templateFilePath));
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0);
            for (int i = 1; i <= sheet.getLastRowNum(); i++) { // Skip header
                Row row = sheet.getRow(i);
                String fieldName = row.getCell(0).getStringCellValue();
                int startPosition = (int) row.getCell(1).getNumericCellValue();
                int length = (int) row.getCell(2).getNumericCellValue();
                int maxOccurrence = (int) row.getCell(3).getNumericCellValue();
                String jsonPath = row.getCell(4).getStringCellValue();
                String dataType = row.getCell(5).getStringCellValue();

                templateConfig.add(new TemplateField(fieldName, startPosition, length, maxOccurrence, jsonPath, dataType));
            }
        }
        return templateConfig;
    }

    // Parse data from the text file based on template configuration
    public static List<Map<String, String>> parseData(List<String> dataLines, List<TemplateField> templateConfig) {
        List<Map<String, String>> parsedData = new ArrayList<>();

        for (String record : dataLines) {
            Map<String, String> fieldValues = new HashMap<>();
            for (TemplateField field : templateConfig) {
                int startPos = field.startPosition();
                int length = field.length();
                String fieldValue = record.substring(startPos, Math.min(startPos + length, record.length())).trim();
                fieldValues.put(field.fieldName(), fieldValue);
            }
            parsedData.add(fieldValues);
        }
        return parsedData;
    }

    // Build JSON structure based on parsed data and template configuration
    public static JSONObject buildJson(List<Map<String, String>> parsedData, List<TemplateField> templateConfig) {
        JSONArray requestList = new JSONArray();

        for (Map<String, String> record : parsedData) {
            JSONObject recordJson = new JSONObject();
            Map<String, JSONObject> jsonObjects = new HashMap<>();

            for (TemplateField field : templateConfig) {
                String fieldName = field.fieldName();
                String jsonPath = field.jsonPath();
                String dataType = field.dataType();
                int maxOccurrence = field.maxOccurrence();

                Object value = castValue(record.get(fieldName), dataType);

                // Handle fields that are directly in the root JSON (e.g., name, age)
                if (!jsonPath.contains("[*]")) {
                    recordJson.put(jsonPath, value);
                } else {
                    // Handle fields that need to be grouped into objects inside arrays
                    String arrayKey = jsonPath.split("\\[\\*\\]")[0]; // Get the root path (e.g., contactList)
                    String objectKey = jsonPath.substring(jsonPath.lastIndexOf(".") + 1); // Get the actual field name

                    JSONObject jsonObject = jsonObjects.getOrDefault(arrayKey, new JSONObject());

                    // Group email and phone in the same object
                    if (arrayKey.equals("contactList") && (objectKey.equals("email") || objectKey.equals("phone"))) {
                        jsonObject.put(objectKey, value);
                    } else {
                        JSONArray array = jsonObjects.containsKey(arrayKey) ? jsonObject.optJSONArray(objectKey) : new JSONArray();
                        array.put(value);
                        jsonObject.put(objectKey, array);
                    }

                    jsonObjects.put(arrayKey, jsonObject);
                }
            }

            // Add grouped objects to the main JSON object
            for (Map.Entry<String, JSONObject> entry : jsonObjects.entrySet()) {
                recordJson.put(entry.getKey(), entry.getValue());
            }

            requestList.put(recordJson);
        }

        JSONObject finalJson = new JSONObject();
        finalJson.put("requestList", requestList);
        return finalJson;
    }

    // Cast values according to their data type
    private static Object castValue(String value, String dataType) {
        return switch (dataType.toLowerCase()) {
            case "int" -> Integer.parseInt(value);
            case "double" -> Double.parseDouble(value);
            case "date" -> value; // Assuming date is in an acceptable string format
            default -> value; // String by default
        };
    }
}
