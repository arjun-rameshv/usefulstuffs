import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

public class GenericFileToJsonConverter {

    public static void main(String[] args) throws Exception {
        String templatePath = "template.xlsx";
        String dataFilePath = "data.txt";

        List<Map<String, String>> templateConfig = readTemplate(templatePath);
        String data = new String(Files.readAllBytes(Paths.get(dataFilePath)));

        List<Map<String, String>> parsedData = parseData(data, templateConfig);
        JSONObject jsonObject = buildJson(parsedData, templateConfig);

        System.out.println(jsonObject.toString(4));
    }

    // Read template configuration from Excel file
    public static List<Map<String, String>> readTemplate(String templateFilePath) throws Exception {
        List<Map<String, String>> templateConfig = new ArrayList<>();
        try (FileInputStream fis = new FileInputStream(new File(templateFilePath));
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0);
            for (int i = 1; i <= sheet.getLastRowNum(); i++) { // Skip header
                Row row = sheet.getRow(i);
                Map<String, String> fieldConfig = new HashMap<>();
                fieldConfig.put("fieldName", row.getCell(0).getStringCellValue());
                fieldConfig.put("startPosition", Integer.toString((int) row.getCell(1).getNumericCellValue()));
                fieldConfig.put("length", Integer.toString((int) row.getCell(2).getNumericCellValue()));
                fieldConfig.put("maxOccurrence", Integer.toString((int) row.getCell(3).getNumericCellValue()));
                fieldConfig.put("jsonPath", row.getCell(4).getStringCellValue());
                fieldConfig.put("dataType", row.getCell(5).getStringCellValue());
                templateConfig.add(fieldConfig);
            }
        }
        return templateConfig;
    }

    // Parse data from the text file based on template configuration
    public static List<Map<String, String>> parseData(String data, List<Map<String, String>> templateConfig) {
        List<Map<String, String>> parsedData = new ArrayList<>();
        String[] records = data.split("\n");

        for (String record : records) {
            Map<String, String> fieldValues = new HashMap<>();
            for (Map<String, String> config : templateConfig) {
                int startPos = Integer.parseInt(config.get("startPosition"));
                int length = Integer.parseInt(config.get("length"));
                String fieldValue = record.substring(startPos, Math.min(startPos + length, record.length())).trim();
                fieldValues.put(config.get("fieldName"), fieldValue);
            }
            parsedData.add(fieldValues);
        }
        return parsedData;
    }

    // Build JSON structure based on parsed data and template configuration
    public static JSONObject buildJson(List<Map<String, String>> parsedData, List<Map<String, String>> templateConfig) {
        JSONArray requestList = new JSONArray();

        for (Map<String, String> record : parsedData) {
            JSONObject recordJson = new JSONObject();
            Map<String, JSONObject> jsonObjects = new HashMap<>();

            for (Map<String, String> config : templateConfig) {
                String fieldName = config.get("fieldName");
                String jsonPath = config.get("jsonPath");
                String dataType = config.get("dataType");
                int maxOccurrence = Integer.parseInt(config.get("maxOccurrence"));

                Object value = castValue(record.get(fieldName), dataType);

                // Handle fields that are directly in the root JSON (e.g., name, age)
                if (!jsonPath.contains("[*]")) {
                    recordJson.put(jsonPath, value);
                } else {
                    // Handle fields that need to be grouped into objects inside arrays
                    String arrayKey = jsonPath.split("\\[\\*\\]")[0]; // Get the root path (e.g., contactList)
                    String objectKey = jsonPath.substring(jsonPath.lastIndexOf(".") + 1); // Get the actual field name

                    JSONObject jsonObject = jsonObjects.getOrDefault(arrayKey, new JSONObject());

                    // Group email and phone in the same object
                    if (arrayKey.equals("contactList") && (objectKey.equals("email") || objectKey.equals("phone"))) {
                        jsonObject.put(objectKey, value);
                    } else {
                        JSONArray array = jsonObjects.containsKey(arrayKey) ? jsonObject.optJSONArray(objectKey) : new JSONArray();
                        array.put(value);
                        jsonObject.put(objectKey, array);
                    }

                    jsonObjects.put(arrayKey, jsonObject);
                }
            }

            // Add grouped objects to the main JSON object
            for (Map.Entry<String, JSONObject> entry : jsonObjects.entrySet()) {
                recordJson.put(entry.getKey(), entry.getValue());
            }

            requestList.put(recordJson);
        }

        JSONObject finalJson = new JSONObject();
        finalJson.put("requestList", requestList);
        return finalJson;
    }

    // Cast values according to their data type
    private static Object castValue(String value, String dataType) {
        switch (dataType.toLowerCase()) {
            case "int":
                return Integer.parseInt(value);
            case "double":
                return Double.parseDouble(value);
            case "date":
                return value; // Assuming date is in an acceptable string format
            default:
                return value; // String by default
        }
    }
}
