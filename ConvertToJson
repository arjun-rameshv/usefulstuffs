import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.util.*;

public class SpaceSeparatedToJsonWithDataType {

    public static void main(String[] args) throws Exception {
        // Load mappings from Excel file
        List<FieldMapping> mappings = readExcelMappingFile("mapping_with_datatype.xlsx");

        // Space-separated input file
        String spaceSeparatedFilePath = "input.txt";

        // JSON output file
        String jsonOutputPath = "output.json";

        // Read the space-separated file
        List<Map<String, String>> parsedRows = readSpaceSeparatedFile(spaceSeparatedFilePath, mappings);

        // Convert parsed rows to JSON
        ArrayNode jsonArray = convertToJson(parsedRows, mappings);

        // Write JSON to file
        ObjectMapper mapper = new ObjectMapper();
        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(jsonOutputPath), jsonArray);

        System.out.println("JSON generated: " + jsonOutputPath);
    }

    // Read and parse the space-separated file
    private static List<Map<String, String>> readSpaceSeparatedFile(String filePath, List<FieldMapping> mappings) throws IOException {
        List<Map<String, String>> rows = new ArrayList<>();

        BufferedReader reader = new BufferedReader(new FileReader(filePath));
        String line;

        while ((line = reader.readLine()) != null) {
            Map<String, String> row = new HashMap<>();

            for (FieldMapping mapping : mappings) {
                int start = mapping.getStartPosition() - 1; // Start position is 1-based in Excel, convert to 0-based
                int end = Math.min(start + mapping.getLength(), line.length());

                String fieldValue = line.substring(start, end).trim();
                row.put(mapping.getFieldName(), fieldValue);
            }

            rows.add(row);
        }

        reader.close();
        return rows;
    }

    // Convert parsed rows to JSON using mappings
    private static ArrayNode convertToJson(List<Map<String, String>> parsedRows, List<FieldMapping> mappings) {
        ObjectMapper mapper = new ObjectMapper();
        ArrayNode jsonArray = mapper.createArrayNode();

        for (Map<String, String> parsedRow : parsedRows) {
            ObjectNode rootObject = mapper.createObjectNode();

            for (FieldMapping mapping : mappings) {
                String value = parsedRow.get(mapping.getFieldName());

                // Convert the value based on the data type
                Object convertedValue = convertToDataType(value, mapping.getDataType());

                // Use JSONPath to dynamically set the value in the corresponding JSON structure
                setJsonValue(rootObject, mapping.getJsonPath(), convertedValue, mapping.getOccurrence());
            }

            jsonArray.add(rootObject);
        }

        return jsonArray;
    }

    // Convert string value to the specified data type
    private static Object convertToDataType(String value, String dataType) {
        switch (dataType.toLowerCase()) {
            case "integer":
                return Integer.parseInt(value);
            case "double":
                return Double.parseDouble(value);
            case "boolean":
                return Boolean.parseBoolean(value);
            default: // Treat as string
                return value;
        }
    }

    // Dynamically set JSON values using the JSONPath
    private static void setJsonValue(ObjectNode rootObject, String jsonPath, Object value, int occurrence) {
        String[] pathParts = jsonPath.replace("$.", "").split("\\.");

        ObjectNode currentNode = rootObject;

        for (int i = 0; i < pathParts.length - 1; i++) {
            String part = pathParts[i];
            if (!currentNode.has(part)) {
                currentNode.set(part, new ObjectNode(null));
            }
            currentNode = (ObjectNode) currentNode.get(part);
        }

        String lastPart = pathParts[pathParts.length - 1];
        if (occurrence > 1) {
            // Handle arrays with occurrences
            if (!currentNode.has(lastPart)) {
                currentNode.putArray(lastPart);
            }
            ArrayNode arrayNode = (ArrayNode) currentNode.get(lastPart);
            arrayNode.addPOJO(value);
        } else {
            // Handle normal fields
            currentNode.putPOJO(lastPart, value);
        }
    }

    // Read the Excel mapping file
    private static List<FieldMapping> readExcelMappingFile(String excelFilePath) throws Exception {
        List<FieldMapping> mappings = new ArrayList<>();

        FileInputStream fis = new FileInputStream(new File(excelFilePath));
        Workbook workbook = new XSSFWorkbook(fis);
        Sheet sheet = workbook.getSheetAt(0);

        Iterator<Row> rowIterator = sheet.iterator();
        rowIterator.next(); // Skip the header row

        while (rowIterator.hasNext()) {
            Row row = rowIterator.next();

            String fieldName = row.getCell(0).getStringCellValue();
            int startPosition = (int) row.getCell(1).getNumericCellValue();
            int length = (int) row.getCell(2).getNumericCellValue();
            int occurrence = (int) row.getCell(3).getNumericCellValue();
            String jsonPath = row.getCell(4).getStringCellValue();
            String dataType = row.getCell(5).getStringCellValue();

            FieldMapping mapping = new FieldMapping(fieldName, startPosition, length, occurrence, jsonPath, dataType);
            mappings.add(mapping);
        }

        workbook.close();
        fis.close();

        return mappings;
    }
}

class FieldMapping {
    private String fieldName;
    private int startPosition;
    private int length;
    private int occurrence;
    private String jsonPath;
    private String dataType;

    public FieldMapping(String fieldName, int startPosition, int length, int occurrence, String jsonPath, String dataType) {
        this.fieldName = fieldName;
        this.startPosition = startPosition;
        this.length = length;
        this.occurrence = occurrence;
        this.jsonPath = jsonPath;
        this.dataType = dataType;
    }

    public String getFieldName() {
        return fieldName;
    }

    public int getStartPosition() {
        return startPosition;
    }

    public int getLength() {
        return length;
    }

    public int getOccurrence() {
        return occurrence;
    }

    public String getJsonPath() {
        return jsonPath;
    }

    public String getDataType() {
        return dataType;
    }
}
